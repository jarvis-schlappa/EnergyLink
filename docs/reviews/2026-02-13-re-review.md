> **Historisches Dokument.** Viele der hier genannten Punkte wurden inzwischen umgesetzt.

# EnergyLink v1.0.2 Re-Review: Security & Refactoring Analysis

**Datum:** 13. Februar 2026  
**Reviewer:** Claude  
**Basis:** Refactoring-Stand nach erstem Code-Review  
**Kontext:** LAN-only-Anwendung, öffentlicher Zugriff nur im Demo-Modus

## Zusammenfassung

Das Refactoring adressiert alle 12 Empfehlungen aus dem ersten Review — die meisten davon substanziell und handwerklich sauber umgesetzt. Die kritischsten Probleme (Command Injection, fehlende Auth, Error-Handler-Crash) sind behoben. Die Codebasis hat sich von einem beeindruckenden Hobby-Projekt zu einer wartbaren, testbaren Anwendung entwickelt.

### Scorecard: Vorher → Nachher

| Kategorie | Vorher | Nachher | Δ |
|-----------|--------|---------|---|
| Sicherheit | ★★☆☆☆ | ★★★★☆ | +2 |
| Architektur | ★★★☆☆ | ★★★★☆ | +1 |
| Code-Qualität | ★★★½☆ | ★★★★☆ | +½ |
| Robustheit | ★★★★☆ | ★★★★½ | +½ |
| Testabdeckung | ☆☆☆☆☆ | ★★★☆☆ | +3 |
| Frontend | ★★★½☆ | ★★★★☆ | +½ |
| DevOps | ★★½☆☆ | ★★★★☆ | +1½ |

## Empfehlung für Empfehlung: Was wurde umgesetzt?

### Priorität 1 — KRITISCH

#### ✅ #1 Command Injection geschlossen

**Vorher:** `req.body.command` → direkt an `execAsync()` — beliebiger Shell-Code ausführbar.

**Nachher:** Mehrstufige Absicherung in `e3dc-client.ts`:

- **Whitelist-Validation** (`validateE3dcCommand()`): Nur bekannte e3dcset-Flags (`-d, -a, -c, -e, -s, -r, -l, -H, -D, -m, -q, -E`) werden akzeptiert.
- **Typ-Prüfung pro Flag:** number-Flags akzeptieren nur `/^\d+$/`, string-Flags nur `/^[a-zA-Z0-9_.\-:]+$/`.
- **Shell-Metazeichen werden blockiert:** `;`, `|`, `` ` ``, `$()`, `&&`, `>`

Die Exportierung von `validateE3dcCommand()` als testbare Funktion ist sauberes Design.

**Verbleibender Hinweis:** Der `prefix` aus `E3dcConfig` wird unvalidiert an `execAsync()` übergeben (`${prefix} ${safeCommand}`). Im LAN-Kontext ist das vertretbar, weil der Prefix aus den Settings kommt, die man selbst konfiguriert — aber wenn je eine Multi-User-Umgebung entstehen sollte, wäre hier ein weiterer Validierungspunkt nötig.

#### ✅ #2 Authentifizierung eingebaut

Gut umgesetzte API-Key-Middleware in `auth.ts`:

- **Timing-Safe-Vergleich** via `crypto.timingSafeEqual()` — schützt gegen Timing-Angriffe.
- **Zwei Header-Varianten:** `Authorization: Bearer <key>` und `X-API-Key: <key>`.
- **Graceful Degradation:** Ohne `API_KEY`-Umgebungsvariable → Legacy-Modus (alles offen) — perfekt für bestehende LAN-Installationen.
- **Health-Check exempt:** `/api/health` liegt vor der Auth-Middleware — Monitoring-Tools brauchen keinen Key.
- **Umfangreiche Tests:** 10 Test-Cases in `auth.test.ts`, inkl. Sonderzeichen, Fallback-Logik, leere Tokens.

Im reinen LAN-Betrieb ohne gesetzte `API_KEY` bleibt alles wie vorher — kluge Rückwärtskompatibilität.

#### ✅ #3 Error-Handler gefixt

**Vorher:** `throw err` nach `res.status().json()` → Server-Crash bei jedem Fehler.

**Nachher:** Sauberer Error-Handler ohne throw:

```typescript
app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
  const status = err.status || err.statusCode || 500;
  const message = err.message || "Internal Server Error";
  res.status(status).json({ message });
});
```

Plus dedizierter Test in `error-handler.test.ts`.

### Priorität 2 — WICHTIG

#### ✅ #4 Tests geschrieben

Von `"test": "echo 'No tests specified'"` zu **1.879 Zeilen Tests** in 15 Test-Dateien:

| Testbereich | Datei | Zeilen |
|-------------|-------|--------|
| Ladestrategie-Kernlogik | charging-strategy.test.ts | 296 |
| Ladestrategie-Randfälle | charging-strategy-edge-cases.test.ts | 181 |
| Auth-Middleware | auth.test.ts | 169 |
| Schema-Validierung | schema.test.ts (shared) | 165 |
| Storage / Atomic Writes | storage.test.ts | 161 |
| UDP-Retry-Logik | udp-retry.test.ts | 153 |
| Zeitbereich-Logik | helpers.test.ts | 136 |
| E3DC-Command-Validation | e3dc-command-validation.test.ts | 134 |
| Status-Routes | status-routes.test.ts | 132 |
| Error-Boundary (Client) | error-boundary.test.tsx | 82 |
| Env-Validierung | env-validation.test.ts | 77 |
| Time-Range | time-range.test.ts | 64 |
| Error-Handler | error-handler.test.ts | 59 |
| Health-Endpoint | health.test.ts | 45 |
| Singleton-Pattern | strategy-singleton.test.ts | 25 |

Vitest-Setup mit Aliases, Coverage-Support und jsdom für React-Tests ist professionell konfiguriert.

**Was noch fehlen darf (Backlog):** Integrationstests mit Supertest gegen den laufenden Express-Server, E2E für die kritischen UDP-Command-Queue-Pfade. Das Shell-basierte `e2e/demo-api-test.sh` ist ein pragmatischer Anfang.

#### ✅ #5 routes.ts aufgespalten

**Vorher:** Eine monolithische 1.968-Zeilen-Datei.

**Nachher:** Sauber aufgeteilt in 8 Module:

| Modul | Zeilen | Verantwortung |
|-------|--------|---------------|
| wallbox-routes.ts | 447 | Wallbox-Steuerung (Start/Stop, Strom, Status) |
| scheduler.ts | 612 | Night-Charging, Strategien, Poller |
| settings-routes.ts | 495 | Einstellungen, E3DC-Config, Demo-Modus |
| helpers.ts | 239 | FHEM, SmartHome, Zeitlogik |
| shared-state.ts | 141 | Singleton-State, Battery-Lock-Logik |
| e3dc-routes.ts | 137 | E3DC-Endpunkte |
| status-routes.ts | 48 | Konsolidierter Status-Endpoint |
| index.ts | 33 | Router-Registration |

Die alte `routes.ts` ist jetzt ein 4-Zeilen-Barrel-Export — saubere Rückwärtskompatibilität.

#### ✅ #6 ChargingStrategyController Singleton

**Vorher:** Zwei separate Instanzen in `routes.ts` und `wallbox-broadcast-listener.ts` → inkonsistenter State.

**Nachher:** `getOrCreateStrategyController()` in `shared-state.ts` garantiert eine einzige Instanz. Der Broadcast-Listener verwendet ausschließlich `getOrCreateStrategyController()` (verifiziert: kein `new ChargingStrategyController` mehr). Eigener Test bestätigt das Singleton-Verhalten.

#### ✅ #7 Atomares File-Writing

**Vorher:** `writeFileSync()` direkt — Datenverlust bei Stromausfall möglich.

**Nachher:** `atomicWriteFileSync()` mit Write-to-Temp + `renameSync()`:

```typescript
function atomicWriteFileSync(filePath: string, data: string): void {
  const tmpPath = filePath + ".tmp";
  writeFileSync(tmpPath, data, encoding);
  try {
    renameSync(tmpPath, filePath);
  } catch (renameError) {
    try { unlinkSync(tmpPath); } catch { }
    throw renameError;
  }
}
```

Alle 6 Schreib-Operationen in `storage.ts` nutzen die neue Funktion — verifiziert per Grep. Kein `writeFileSync` mehr außer in der atomaren Hilfsfunktion selbst.

### Priorität 3 — VERBESSERUNGEN

#### ✅ #8 Konsolidierter Status-Endpoint

Neuer `/api/status`-Endpoint in `status-routes.ts` kombiniert Settings, Controls, Plug-Tracking, Charging-Context, E3DC-Live-Data, Grid-Frequency und Build-Info in einem einzigen Response — statt 5 paralleler Polls alle 5 Sekunden.

#### ✅ #9 UDP-Retry-Logik

`wallbox-transport.ts` implementiert exponentielles Backoff:

- Konfigurierbar: `maxAttempts`, `baseDelayMs`, `backoffFactor`
- Standard: 3 Versuche, 500ms Basis, Faktor 2 (also 500ms → 1000ms → fertig)
- Nur Timeout-Fehler werden geretried — andere Fehler brechen sofort ab
- 6 Tests in `udp-retry.test.ts` (Hinweis: Tests testen eine extrahierte Retry-Funktion, nicht den echten Transport)

#### ✅ #10 Frontend-Verbesserungen

- **ErrorBoundary** implementiert: Fängt Render-Fehler, zeigt deutsches Fallback-UI mit „Erneut versuchen" und „Seite neu laden", getestet mit 4 Test-Cases.
- **Seitengrößen deutlich reduziert:** SettingsPage 1.670 → 348 Zeilen, StatusPage 1.055 → 659 Zeilen.

#### ✅ #11 Cleanup

- `storage.ts.broken` und `storage.ts.orig` entfernt
- Package-Name von `"rest-express"` auf `"energylink"` korrigiert
- Drizzle/Neon/Passport-Dependencies entfernt

#### ✅ #12 Dockerfile optimiert

Production-Stage nutzt jetzt `npm ci --omit=dev` — nur Production-Dependencies im finalen Image. Saubere Multi-Stage-Build-Trennung.

## Zusätzliche Verbesserungen (über das Review hinaus)

Einiges wurde umgesetzt, was im Review erwähnt, aber nicht explizit als Empfehlung formuliert war:

- **Health-Check-Endpoint** (`/api/health`): Version, Uptime, Timestamp — unauthentifiziert für Monitoring.
- **Environment-Validierung** (`env-validation.ts`): Pflicht- und optionale Vars werden beim Start geprüft, fehlende Pflicht-Vars → `process.exit(1)`.
- **SSRF-Schutz** für SmartHome-URLs: `isSmartHomeUrlAllowed()` blockiert Link-Local (169.254.x.x), Null-Adressen, und erlaubt optionale Allowlist via `ALLOWED_SMARTHOME_ORIGINS`.
- **Build-Info-System** (`build-info.ts`): Git-Branch, Commit, Build-Zeit im `/api/status`.
- **E2E-Testskript** (`e2e/demo-api-test.sh`): Shell-basierte API-Smoke-Tests für Demo-Modus.

## Verbliebene Hinweise

Keine dieser Punkte ist für den aktuellen LAN-Einsatz kritisch. Sie sind Anregungen für die Weiterentwicklung.

### 1. Hardcoded Default-IP 192.168.40.16

Taucht noch an 5 Stellen als Fallback auf (`storage.ts`, `charging-strategy-controller.ts`, `scheduler.ts`, `settings-routes.ts`). Könnte als Konstante oder über die Env-Validierung zentralisiert werden — ist aber kein echtes Problem, weil die IP sofort über die Einstellungen überschrieben wird.

→ **Issue #37**

### 2. `settings: any` in shared-state.ts

Die vier Battery-/Grid-Funktionen (`lockBatteryDischarge`, `unlockBatteryDischarge`, `enableGridCharging`, `disableGridCharging`) verwenden `settings: any` statt des typisierten Settings-Interfaces. Ein Import von `Settings` aus `@shared/schema` würde hier Typensicherheit herstellen.

→ **Issue #38**

### 3. FHEM-Statusabfrage bleibt HTML-basierend

`getFhemDeviceState()` parsed weiterhin FHEM-HTML mit Regex. Für den Heimgebrauch funktioniert das — FHEM bietet auch eine JSON-API (`?cmd=jsonlist2`), die robuster wäre. Kein Handlungsbedarf, nur als Option erwähnt.

### 4. Radix-Paketliste

27 Radix-UI-Pakete in den Dependencies — einige davon (Accordion, Avatar, ContextMenu, HoverCard, Menubar, NavigationMenu, OTP, ResizablePanels) werden vermutlich nicht alle verwendet. Ein `depcheck` könnte das Image und `npm ci`-Zeit um einige MB reduzieren. Niedrige Priorität.

→ **Issue #39**

### 5. prefix in e3dc-client.ts

Der `prefix` aus den Settings (Pfad zum e3dcset-Binary, z.B. `/usr/local/bin/e3dcset -p /path/to/config`) wird nicht gegen die Command-Whitelist validiert, weil er nicht user-eingegeben im klassischen Sinne ist — er wird in den Einstellungen konfiguriert. Im LAN-Kontext ist das kein Problem, weil derselbe Benutzer, der den Prefix setzt, auch SSH-Zugriff hat. Nur relevant, falls je Multi-User-Support kommen sollte.

## Gesamtbewertung

| Kategorie | Bewertung | Kommentar |
|-----------|-----------|-----------|
| Funktionalität | ★★★★★ | Unverändert exzellent |
| Architektur | ★★★★☆ | Modulare Routes, Singleton-Pattern, Health-Check |
| Code-Qualität | ★★★★☆ | Tests, Atomic Writes, saubere Trennung |
| Sicherheit | ★★★★☆ | Command-Whitelist, API-Key-Auth, SSRF-Schutz |
| Robustheit | ★★★★½ | UDP-Retry, atomare Persistierung, Error Boundary |
| Testabdeckung | ★★★☆☆ | Solide Basis (1.879 Zeilen), Integrationstests ausbaubar |
| Frontend | ★★★★☆ | Kompaktere Seiten, ErrorBoundary, konsolidiertes Polling |
| DevOps | ★★★★☆ | Optimierter Docker, Env-Validierung, Health-Check |

**Fazit:** Das Refactoring ist gründlich und durchdacht. Jede einzelne Empfehlung aus dem ersten Review wurde adressiert — das ist selten. Besonders hervorzuheben sind die Sicherheitsverbesserungen (Command-Whitelist mit Tests statt simpler Regex-Filter) und das pragmatische Auth-Konzept (optional, rückwärtskompatibel, timing-safe). Die Codebasis ist jetzt in einem Zustand, der Weiterentwicklung und Wartung deutlich erleichtert.
